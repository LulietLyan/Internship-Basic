---
statistics: true
comments: true
---

<style>
body {
  position: relative; /* 确保 body 元素的 position 属性为非静态值 */
}

body::before {
  --size: 35px; /* 调整网格单元大小 */
  --line: color-mix(in hsl, canvasText, transparent 60%); /* 调整线条透明度 */
  content: '';
  height: 100vh;
  width: 100%;
  position: absolute; /* 修改为 absolute 以使其随页面滚动 */
  background: linear-gradient(
        90deg,
        var(--line) 1px,
        transparent 1px var(--size)
      )
      50% 50% / var(--size) var(--size),
    linear-gradient(var(--line) 1px, transparent 1px var(--size)) 50% 50% /
      var(--size) var(--size);
  -webkit-mask: linear-gradient(-20deg, transparent 30%, white 80%);
          mask: linear-gradient(-20deg, transparent 30%, white 80%);
  top: 0;
  transform-style: flat;
  pointer-events: none;
  z-index: -1;
}

@media (max-width: 768px) {
  body::before {
    display: none; /* 在手机端隐藏网格效果 */
  }
}
</style>

# 🟢 IP

## IP 地址的分类

主机号全 0 或全 1 的地址不可用：

- **A 类**：0.0.0.0 ~ 127.255.255.255
- **B 类**：128.0.0.0 ~ 191.255.255.255
- **C 类**：192.0.0.0 ~ 223.255.255.255
- **D 类**：224.0.0.0 ~ 239.255.255.255，用于多播，即将包发送给特定组内的所有主机
- **E 类**：240.0.0.0 ~ 255.255.255.255，保留使用

## 无分类地址 CIDR

以表示形式 `a.b.c.d/x` 表示 IP。其中 `/x` 表示前 x 位属于 **网络号**，x 的范围是 `0 ~ 32`，使得 IP 地址更加具有灵活性。

## IP 地址与路由控制

IP 地址的 **网络地址** 这一部分用于进行路由控制。路由控制表中记录着网络地址与下一步应该发送至路由器的地址。在主机和路由器上都会有各自的路由器控制表。

在发送 IP 包时首先要确定 IP 包首部中的目标地址，再从路由控制表中找到与该地址具有 **相同网络地址** 的记录，根据该记录将 IP 包转发给相应的下一个路由器。如果路由控制表中存在多条相同网络地址的记录，就选择相同位数最多的网络地址，也就是最长匹配。

## IP 分片与重组

每种数据链路的最大传输单元 `MTU` 都是不相同的，如 FDDI 数据链路 MTU 4352、以太网的 MTU 是 1500 字节等。每种数据链路的 MTU 之所以不同，是因为每个不同类型的数据链路的使用目的不同。使用目的不同，可承载的 MTU 也就不同。其中最常见数据链路是以太网，它的 MTU 是 `1500` 字节。当 IP 数据包大小大于 MTU 时，IP 数据包就会被分片。经过分片之后的 IP 数据报在被重组时只能由目标主机进行，路由器是不会进行重组的。

## DNS 查询服务器的基本流程？

- 客户机向其本地域名服务器发出 DNS 请求报文
- 本地域名服务器收到请求后，查询本地缓存，假设没有该记录，则以 DNS 客户的身份向 **根域名服务器** 发出解析请求
- 根域名服务器收到请求后，判断该域名所属域，将对应的 **顶级域名服务器** 的 IP 地址返回给本地域名服务器
- 本地域名服务器向顶级域名服务器发出解析请求报文
- 顶级域名服务器收到请求后，将所对应的 **授权域名服务器** 的 IP 地址返回给 **本地域名服务器** 
- 本地域名服务器向授权域名服务器发起解析请求报文
- 授权域名服务器收到请求后，将 **查询结果返回给本地域名服务器** 
- 本地域名服务器将查询结果 **保存到本地缓存**，同时返回给客户机

## DNS 采用 TCP 还是 UDP，为什么？

DNS 在 **进行区域传输的时候使用 TCP 协议**， **其它时候则使用 UDP 协议**。TCP 与 UDP 传送字节的长度限制不同，一般情况下一个 DNS 的 UDP 包的最大长度是 512 字节。

区域传输使用 TCP 协议的原因大概是：

- 区域传输的数据量相比单次 DNS 查询的数据量要大得多
- 区域传输对数据的可靠性和准确性相比普通的 DNS 查询要要高得多，因此使用 TCP 协议

域名解析时一般返回的内容都不超过 512 字节，首选的通讯协议是 UDP。使用 UDP 传输，不用经过 TCP 三次握手，这样 DNS 服务器负载更低，响应更快。

## DNS 劫持是什么？解决办法？

### 概念

- **本地 DNS 劫持**：攻击者在用户的计算机上安装木马恶意软件，并更改本地 DNS 设置以将用户重定向到恶意站点
- **路由器 DNS 劫持**：攻击者接管路由器并覆盖 DNS 设置，从而影响连接到该路由器的所有用户
- **中间人 DNS 攻击**：攻击者拦截用户和 DNS 服务器之间的通信，并提供指向恶意站点的不同目标 IP 地址

### 解决方法

- **加强域名账户的安全防护能力**，使用有别于其他平台的用户名和强密码，定期对密码进行更换
- **定期查看域名账户信息、域名 whois 信息、域名解析状态**，每天 site 网站检查是否存在非个人设定网页，发现异常及时联系域名服务商
- **锁定域名解析状态**，不允许通过 DNS 服务商网站修改记录，使用此方法后，需要做域名解析都要通过服务商来完成，这样可以从根本上杜绝通过攻击服务商修改解析记录的方法

## 关于 ARP

ARP 协议用于求下一跳的 MAC 地址。这个过程通过 **ARP 请求** 与 **ARP 响应** 完成：

- **主机通过广播发送 ARP 请求**：请求中包含了想要知道的 MAC 地址的主机 IP 地址
- **当同个链路中的所有设备收到 ARP 请求时会拆开 ARP 请求包里的内容**：如果 ARP 请求包中的目标 IP 地址与自己的 IP 地址一致，该设备将自己的 MAC 地址加入 ARP 响应包返回给主机

## 关于 DHCP

DHCP 可以为设备动态获取 IP 地址：

- **客户端发起 DHCP 发现报文(DHCP DISCOVER)**：由于客户端没有 IP 地址，也不知道 DHCP 服务器的地址，所以使用的是 **UDP 广播通信**。其使用的广播目的地址是 255.255.255.255(端口 67)并且使用 0.0.0.0(端口 68)作为源 IP 地址。DHCP 客户端将该 IP 数据报传递给链路层，链路层将帧广播到所有的网络中设备
- **DHCP 服务器收到 DHCP 发现报文时用 DHCP 提供报文(DHCP OFFER)向客户端做出响应**：该报文仍然使用 IP 广播地址 255.255.255.255，该报文信息携带服务器提供可租约的 IP 地址、子网掩码、默认网关、DNS 服务器以及 **IP 地址租用期**
- 客户端收到一个或多个服务器的 DHCP 提供报文后从中选择一个服务器，并向选中的服务器发送 **DHCP 请求报文(DHCP REQUEST** 进行响应，回显配置的参数
- 最后，服务端用 **DHCP ACK 报文** 对 DHCP 请求报文进行响应，应答所要求的参数

## 浏览器输入一个 URL 到显示器显示的过程？

- **键盘输入**：输入键盘字符后键盘就会产生扫描数据，并将其缓冲存在寄存器中，然后键盘通过总线给 CPU 发送中断请求。CPU 收到中断请求后，操作系统会保存被中断进程的 CPU 上下文，然后调用键盘的中断处理程序。键盘中断处理函数从键盘的寄存器的缓冲区读取扫描码，再根据扫描码找到用户在键盘输入的字符的 ASCII 码。然后把 ASCII 码放到读缓冲区队列，显示器会定时从读缓冲区队列读取数据放到写缓冲区队列，最后把写缓冲区队列的数据一个一个写入到显示器的寄存器中的数据缓冲区，最后将这些数据显示在屏幕里
- **URL 解析**：浏览器会首先从缓存中找是否存在域名，如果存在就直接取出对应的 IP 地址，如果没有就开启一个 DNS 域名解析器。DNS 域名解析器会首先访问顶级域名服务器，将对应的 IP 发给客户端；然后访问根域名解析器，将对应的 IP 发给客户端；最后访问本地域名服务器，得到最终的 IP 地址
- **TCP 连接**：在 URL 解析过程中得到真实的 IP 地址之后，会调用 Socket 函数建立 TCP 连接
- **HTTP 请求**：浏览器向服务器发起一个 HTTP 请求，HTTP 协议是建立在 TCP 协议之上的应用层协议，其本质是建立起的 TCP 连接中，按照 HTTP 协议标准发送一个索要网页的请求。请求包含请求行、请求头、请求体三个部分组成，有 GET、POST 等主要方法
- **浏览器接受响应**：服务器在收到浏览器发送的 HTTP 请求之后，会将收到的 HTTP  报文封装成 HTTP 的 Request 对象，并通过不同的 Web 服务器进行处理，处理完的结果以 HTTP 的 Response 对象返回，主要包括状态码，响应头，响应报文三个部分
- **页面渲染**：浏览器根据响应开始显示页面，首先解析 HTML 文件构建 DOM 树，然后解析 CSS 文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上
- **断开连接**：客户端和服务器通过四次挥手终止 TCP 连接

## 关于 ICMP 协议

ICMP 全称是 **Internet Control Message Protocol**，即 **互联网控制报文协议**。其主要功能有 **确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等**。其报文类型分为 **查询报文** 和 **差错报文**：

- **查询报文**：
    - 回送应答
    - 回送请求
- **差错报文**：
    - 目标不可达
    - 源点抑制
    - 重定向或改变路由
    - 超时

## PING 是怎么工作的？

ping 命令执行的时候，源主机首先会构建一个  **ICMP 回送请求消息数据包**，由 ICMP 协议将这个数据包连同服务端 IP 一起交给 IP 层，IP 层将以服务端 IP 作为目的地址，本机 IP 地址作为源地址，协议字段设置为 1，再加上一些其他控制信息，构建一个 IP 数据包；然后加入 MAC 头；如果在本地 ARP 映射表中查找出服务端 IP 所对应的 MAC 地址，则可以直接使用，如果没有，则需要发送 ARP 协议查询 MAC 地址。 **获得 MAC 地址后，由数据链路层构建一个数据帧，目的地址是 IP 层传过来的 MAC 地址，源地址则是本机的 MAC 地址**；还要附加上一些控制信息，依据以太网的介质访问规则将它们传送出去。

目的主机收到这个数据帧后，先检查它的目的 MAC 地址，并和本机的 MAC 地址对比，如符合，则接收，否则就丢弃。接收后检查该数据帧，将 IP 数据包从帧中提取出来，交给本机的 IP 层。IP 层检查后，将有用的信息提取后交给 ICMP 协议。 **主机 B 会构建一个 ICMP 回送响应消息数据包**，回送响应数据包的类型字段为 0，序号为接收到的请求数据包中的序号，然后再发送出去给主机 A。

在规定的时候间内，源主机如果没有接到 ICMP 的应答包，则说明目标主机不可达；如果接收到了 ICMP 回送响应消息，则说明目标主机可达。

## traceroute 是怎么工作的？

利用 IP 包的 **生存期限** 从 `1` 开始按照顺序递增的同时发送 **UDP 包**，强制接收 **ICMP 超时消息** 的一种方法。例如将 TTL 设置 为 `1`，则遇到第一个路由器就牺牲了，接着返回 ICMP 差错报文网络包，类型是 **时间超时**。接下来将 TTL 设置为 `2`，第一个路由器过了，遇到第二个路由器也牺牲了，也同时返回了 ICMP 差错报文数据包，如此往复，直到到达目的主机。以此类推 traceroute 就可以拿到所有的路由器 IP。

traceroute 的作用主要有：

- 设置特殊的 TTL 追踪去往目的地时沿途经过的路由器
- 设置不分片从而确定路径的 MTU

## Cookie 和 Session 的关系和区别是什么？

### Cookie 概念

Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务器两个请求是否来自同一浏览器。

如保持用户的登录状态， **Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。** 

### Cookie 作用

- **会话状态管理** (如用户登录状态、购物车、游戏分数或其它需要记录的信息)
- **个性化设置** (如用户自定义设置、主题等)
- **浏览器行为跟踪** (如跟踪分析用户行为等)

### Session 概念

Session 代表着服务器和客户端一次会话的过程。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。 **当客户端关闭会话，或者 Session 超时失效时会话结束**。

### 差别

- **作用范围不同**：Cookie 保存在客户端(浏览器)，Session 保存在服务端
- **存取方式的不同**：Cookie 只能保存 ASCII，Session 可以存任意数据类型
- **有效期不同**：Cookie 可设置为长时间保持，比如经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效
- **隐私策略不同**：Cookie 存储在客户端，比较容易遭到不法获取；Session 存储在服务端，安全性相对 Cookie 要好一些
- **存储大小不同**：单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie

## iPv4 和 iPv6 的区别？

- **IPv6 的首部长度是 40 个字节**，相对 IPv4 的首部长度 20 字节要长，但 IPv6 首部结构比 IPv4 简单
- **IPv6 把 IP 地址由 32 位增加到 128 位**，从而能够支持更大的地址空间。IPv6 简化了路由，加快了路由速度
- **IPv6 的可选项不放入报头，而是放在一个个独立的扩展头部**。如果不指定路由器不会打开处理扩展头部， IPv6 放宽了对可选项长度的严格要求 (IPv4 的可选项总长最多为 40 字节)，并可根据需要随时引入新选项
- **IPv6 协议支持地址自动配置**，这是一种即插即用的机制。IPv6 节点通过地址自动配置得到 IPv6 地址和网关地址。IPv6 支持无状态地址自动配置和状态地址自动配置两种地址自动配置方式。它会给配置 128 位的地址带来很大的方便，特别是无状态地址自动配置
- 在 IPv6 中加入了关于身份验证、数据一致性和保密性的内容

## 什么是跨域，什么情况下会发生跨域请求？

### 概念

指的是 **浏览器不能执行其他网站的脚本**。它是由浏览器的同源策略造成的。a 页面想获取 b 页面资源，如果 a、b 页面的协议、域名、端口、子域名不同，所进行的访问行动都是跨域的，而浏览器为了安全问题一般都限制了跨域访问，也就是不允许跨域请求资源

### 解决方法

- **Nginx**：使用 Nginx 作为代理服务器和用户交互，用户就只需要在 80 端口上进行交互就可以了，这样就避免了跨域问题
- **JSONP**：网页通过添加一个 script 元素，向服务器请求 JSON 数据，服务器收到请求后，将数据放在一个指定名字的回调函数的参数位置传回来。缺点是只支持 get 请求，不支持 post 请求
- **CORS**：跨域资源分享
