<h1 align="center">MySQL</h1>

# Contents
- [Contents](#contents)
- [概述](#概述)
  - [关系的三个范式是什么？](#关系的三个范式是什么)
  - [MySQL 中 varchar 和 char 的区别是什么？](#mysql-中-varchar-和-char-的区别是什么)
  - [join 和 left join 的区别？](#join-和-left-join-的区别)
  - [SQL 怎么实现模糊查询？](#sql-怎么实现模糊查询)
  - [select 的执行过程？](#select-的执行过程)
  - [update 的执行过程？](#update-的执行过程)
  - [count 性能比较？](#count-性能比较)
  - [drop、truncate 和 delete 的区别？](#droptruncate-和-delete-的区别)
  - [MySQL 会出现死锁吗，怎么检测死锁？](#mysql-会出现死锁吗怎么检测死锁)
- [事务](#事务)
  - [MySQL 之事务的四大特性(ACID)？](#mysql-之事务的四大特性acid)
  - [并发事务会出现什么问题？](#并发事务会出现什么问题)
  - [MySQL 的事务隔离级别？](#mysql-的事务隔离级别)
  - [在不同事务隔离级别下会发生什么现象？](#在不同事务隔离级别下会发生什么现象)
  - [MVVC 实现原理？](#mvvc-实现原理)
  - [幻读是如何解决的？](#幻读是如何解决的)
  - [读提交怎么实现的？](#读提交怎么实现的)
- [索引](#索引)
  - [MySQL 为什么使用 B+ 树来作索引，它的优势什么？](#mysql-为什么使用-b-树来作索引它的优势什么)
    - [特性和定义](#特性和定义)
    - [优势](#优势)
    - [对比](#对比)
  - [索引有哪些种类？](#索引有哪些种类)
  - [什么是最左匹配原则？](#什么是最左匹配原则)
  - [索引区分度？](#索引区分度)
  - [联合索引如何进行排序？](#联合索引如何进行排序)
  - [使用索引会有哪些缺陷？](#使用索引会有哪些缺陷)
  - [什么时候需要/不需要创建索引？](#什么时候需要不需要创建索引)
    - [需要创建索引](#需要创建索引)
    - [不需要创建索引](#不需要创建索引)
  - [索引的优化(使用索引的注意事项)？](#索引的优化使用索引的注意事项)
  - [WHERE 语句索引使用的注意事项？](#where-语句索引使用的注意事项)
  - [索引什么时候会失效？](#索引什么时候会失效)
- [锁](#锁)
- [存储引擎](#存储引擎)
- [日志](#日志)
- [优化](#优化)

# 概述

## 关系的三个范式是什么？

- **第一范式(1NF)**：用来确保每列的原子性，要求每列(或者每个属性值)都是不可再分的最小数据单元(也称为最小的原子单元)

- **第二范式(2NF)**：在第一范式的基础上更进一层，要求表中的每列都和主键相关，即要求实体的唯一性。如果一个表满足第一范式，并且除了主键以外的其他列全部都依赖于该主键，那么该表满足第二范式

- **第三范式(3NF)**：在第二范式的基础上更进一层，第三范式是确保每列都和主键列直接相关，而不是间接相关，即限制列的冗余性。如果一个关系满足第二范式，并且除了主键以外的其他列都依赖于主键列，列和列之间不存在相互依赖关系，则满足第三范式

## MySQL 中 varchar 和 char 的区别是什么？

- char 字段的最大长度为 255 字符，varchar 字段的最大长度为 65535 个字符
- char 类型如果存的数据量小于最大长度，剩余的空间会使用空格填充，因此可能会浪费空间，所以 char 类型适合存储长度固定的数据，这样不会浪费空间，效率还比 varchar 略高；varchar 类型如果存到数据量小于最大长度，剩余的空间会留给别的数据使用，所以 varchar 类型适合存储长度不固定的数据，这样虽然没有 char 存储效率高，但至少不会浪费空间
- char 类型的查找效率高，varchar 类型的查找效率较低

## join 和 left join 的区别？

- join 等价于 inner join 内连接，是返回两个表中都有的符合条件的行

- left join 左连接，是返回左表中所有的行及右表中符合条件的行

- right join 右连接，是返回右表中所有的行及左表中符合条件的行

## SQL 怎么实现模糊查询？

索引 B+ 树是按照索引值有序排列存储的，只能根据前缀进行比较。每一次按照模糊匹配的前缀字典序来进行比较。

## select 的执行过程？

- **连接**：首先客户端和 MySQL 通过三次握手建立连接，MySQL 是基于 TCP 进行传输的。MySQL 服务如果没有启动就会报错。MySQL 正常运行的话就去校验用户名和密码，如果认证信息错误也会报错。检验通过之后连接器会获取用户权限并且保存起来，后续的任何操作都会基于开始的读到权限进行判断，即便创建连接之后更改了权限也不会影响已连接的权限
  > **长连接解决**
  > **定期断开长连接**
  > **客户端主动重置连接**：当客户端执行了一个很大的操作后，在代码里调用 mysql_reset_connection 函数来重置连接，达到释放内存的效果。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态
- **查询缓存**：连接成功后会向 MySQL 服务发送 SQL 语句，MySQL 服务收到语句之后会进行解析判断 SQL 语句的类型。如果是 select 语句的话就去缓存中查询，看看之前有没有执行过这条 select 语句。缓存是以 k-v 形式保存在内存中的，key 是 SQL 语句，value 是 SQL 查询结果。如果缓存中有结果就直接返回给客户端，如果没有命中就继续向下执行。执行完成后的结果会被放入缓存中
  > **缓存缺点**
  >对于更新比较频繁的表，查询缓存的命中率很低的，只要一个表有更新操作，那么这个表的查询缓存就会被清空。如果刚缓存了一个查询结果很大的数据，还没被使用的时候，刚好这个表有更新操作，查询缓冲就被清空了。
  > **MySQL 8.0 版本直接将查询缓存删掉了**，执行一条 SQL 查询语句，不会有查询缓存这个阶段了
- **SQL 解析**：词法分析和语法分析，词法分析是把 SQL 语句的字符串识别出关键字，方便后续优化，语法分析根据语法规则判断 SQL 语句是否满足要求。如果 SQL 语句不对就会报错
- **SQL 执行**：主要是 prepare 预处理、optimize 优化和 execute 执行阶段。预处理器检查 SQL 查询的表或者字段是否存在，如果有就将它扩展为 SQL 的所有的列。优化器是确定SQL语句的执行方案，比方说有索引会选择走了哪个索引。执行器会与存储引擎交互，如果走索引了就将相应索引条件交给存储引擎，存储引擎通过 B+ 树定位数据，如果数据不存在就像执行器返回错误，然后查询结束，找到了就将记录返回给执行数，执行器读到数据之后判断记录是否满足要求，如果满足要求就将数据返回给客户端，否则跳过该数据。如果是全表扫描优化器和存储引擎交互之后存储引擎会访问第一条表中数据，执行器会判断这条数据是否满足条件，满足就发给客户端，然后执行器查询是一个 while 循环，继续取下一条记录重复判断，直到读完表中所有记录退出循环。如果使用联合索引的话，会在存储引擎层分别判断每个索引是否满足条件，而不先执行回表，所有索引有一个不成立就跳过，否则就返回给 Server 层回表，这是一个索引下推的过程

## update 的执行过程？

**执行器负责具体执行**，会调用存储引擎的接口，通过主键索引树搜索获取一行记录：

- 如果记录所在的数据页本来就在 buffer pool 中，就直接返回给执行器更新
- 如果记录不在 buffer pool，将数据页从磁盘读入到 buffer pool，返回记录给执行器

执行器得到聚簇索引记录后，会**比较更新前的记录和更新后的记录是否相同**：

- 如果一样的话就不进行后续更新流程；
- 如果不一样的话就把更新前的记录和更新后的记录都当作- 参数传给 InnoDB 层，让 InnoDB 真正的执行更新记录的操作；
- **开启事务**，首先要记录相应的 undo log，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面，不过在内存修改该 Undo 页面后，需要记录对应的 redo log。

InnoDB 层开始更新记录，会先更新内存(同时标记为脏页)，然后将记录写到 redo log 里面，这个时候更新就算完成了。为了减少磁盘 I/O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。

在一条更新语句执行完成后，然后开始记录该语句对应的 binlog，此时记录的 binlog 会被保存到 binlog cache，在事务提交时才会统一将该事务运行过程中的所有 binlog 刷新到硬盘。

两阶段提交：

- **prepare 阶段**：将 redo log 对应的事务状态设置为 prepare，然后将 redo log 刷新到硬盘；
- **commit 阶段**：将 binlog 刷新到磁盘，接着调用引擎的提交事务接口，将 redo log 状态设置为 commit(将事务设置为 commit 状态后，刷入到磁盘 redo log 文件)

## count 性能比较？

**count(*) = count(1) > count(主键) > count(字段)**

MySQL 会将星号参数转化为参数 0 来处理，所以 count(*) 和 count(1)相等。count(主键)需要判断主键是否为空值；count(字段)会进行全表扫描，效率最差。

## drop、truncate 和 delete 的区别？

**drop 删除整张表和表结构，以及表的索引、约束和触发器；truncate 只删除表数据，表的结构、索引、约束等会被保留； delete 只删除表的全部或部分数据，表结构、索引、约束等会被保留**。

delete 语句为 DML(data maintain Language)，执行删除操作的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作；truncate、drop 是 DLL(data define language)，删除行是不能恢复的，并且在删除的过程中不会激活与表有关的删除触发器，执行速度快，原数据不放到 rollback segment 中，不能回滚。

truncate 和 drop 不支持添加 where 条件，而 delete 支持 where 条件。

执行速度 **drop > truncate > delete**，delete 是逐行执行的，并且在执行时会把操作日志记录下来，以备日后回滚使用，所以 delete 的执行速度是比较慢的；而 truncate 的操作是先复制一个新的表结构，再把原先的表整体删除，所以它的执行速度居中，而 drop 的执行速度最快。

truncate 只能对 TABLE；delete 可以是 TABLE 和 VIEW。

> **使用场景**
> 如果**想删除表用 drop**；
> 如果**想保留表而将所有数据删除，和事务无关，用 truncate** 即可；
> 如果**和事务有关，或者想触发 trigger，用 delete**；
> 如果是整理表内部的碎片，可以用 truncate 跟上 reuse stroage，再重新导入/插入数据。

## MySQL 会出现死锁吗，怎么检测死锁？ 

如果 update 语句的 where 条件没有用到索引列，那么就会全表扫描，在一行行扫描的过程中，不仅给行记录加上了行锁，还给行记录两边的空隙也加上了间隙锁，相当于锁住整个表，然后直到事务结束才会释放锁。

行锁会发生死锁，表锁不会。死锁的四个必要条件：**互斥、占有且等待、不可强占用、循环等待**。只要系统发生死锁，这些条件必然成立，但是只要破坏任意一个条件就死锁就不会成立。

解决办法：

- **设置事务等待锁的超时时间**：当一个事务的等待时间超过该值后，就对这个事务进行回滚，于是锁就释放了，另一个事务就可以继续执行了。在 InnoDB 中，参数 innodb_lock_wait_timeout 是用来设置超时时间的，默认值时 50 秒。
  
当发生超时后，就出现下面这个提示：

- **开启主动死锁检测**：主动死锁检测在发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑，默认就开启。当检测到死锁后，就会出现提示


# 事务

## MySQL 之事务的四大特性(ACID)？

- **原子性(atomicity)**：一个事务必须视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性
- **一致性(consistency)**：数据库总是从一个一致性的状态转换到另一个一致性的状态
- **隔离性(isolation)**：一个事务所做的修改在最终提交以前，对其他事务是不可见的
- **持久性(durability)**：一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失

> **实现**
> **原子性**：通过 undo log来保证
> **一致性**：通过持久性 + 原子性 + 隔离性来保证
> **隔离性**：通过 MVCC 或锁机制来保证
> **持久性**：通过 redo log来保证

## 并发事务会出现什么问题？

- **脏读**：脏读指的是**读到了其他事务未提交的数据**，未提交意味着这些数据可能会回滚，也就是可能最终不会存到数据库中，也就是不存在的数据。读到了并一定最终存在的数据，这就是脏读
- **不可重复读**：对比可重复读，**不可重复读指的是在同一事务内，不同的时刻读到的同一批数据可能是不一样的**，可能会受到其他事务的影响，比如其他事务改了这批数据并提交了。通常针对数据更新操作
- **幻读**：幻读是针对数据插入操作来说的。假设事务 A 对某些行的内容作了更改，但是还未提交，此时事务 B 插入了与事务 A 更改前的记录相同的记录行，并且在事务 A 提交之前先提交了，而这时，在事务 A 中查询，会发现好像刚刚的更改对于某些数据未起作用，让用户感觉感觉出现了幻觉，这就叫幻读
- **可重复读**：可重复读指的是在一个事务内，最开始读到的数据和事务结束前的任意时刻读到的同一批数据都是一致的

## MySQL 的事务隔离级别？

- **读未提交(read uncommitted)**：指一个事务还没提交时，它做的变更就能被其他事务看到
- **读提交(read committed)**：指一个事务提交之后，它做的变更才能被其他事务看到
- **可重复读(repeatable read)**：指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，MySQL InnoDB 引擎的默认隔离级别
- **串行化(serializable)**：会**对记录加上读写锁**，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行

## 在不同事务隔离级别下会发生什么现象？

- **读未提交**：**可能发生脏读、不可重复读和幻读现象**
- **读提交**：**可能发生不可重复读和幻读现象**，但是不可能发生脏读现象
- **可重复读**：**可能发生幻读现象**，但是不可能脏读和不可重复读现象
- **串行化**：隔离级别下，脏读、不可重复读和幻读现象都不可能会发生

> **💡提示**
> **解决脏读现象**：升级到读提交以上的隔离级别
> **解决不可重复读**：升级到可重复读的隔离级别
> **解决幻读**：**不建议**将隔离级别升级到串行化，因为这样会导致数据库在**并发事务时性能很差**

## MVVC 实现原理？

Read View 有四个重要的字段：

- **m_ids** ：指的是在创建 Read View 时，当前数据库中活跃事务的事务 id 列表，活跃事务指的就是，启动了但还没提交的事务
- **min_trx_id** ：指的是在创建 Read View 时，当前数据库中活跃事务中事务 id 最小的事务，也就是 m_ids 的最小值
- **max_trx_id** ：创建 Read View 时当前数据库中应该给下一个事务的 id 值，也就是全局事务中最大的事务 id 值 + 1
- **creator_trx_id** ：指的是创建该 Read View 的事务的事务 id

对于使用 InnoDB 存储引擎的数据库表，它的聚簇索引记录中都包含下面两个隐藏列：

- **trx_id**：当一个事务对某条聚簇索引记录进行改动时，就会把该事务的事务 id 记录在 trx_id 隐藏列里。
- **roll_pointer**：每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，然后这个隐藏列是个指针，指向每一个旧版本记录，于是就可以通过它找到修改前的记录

一个事务去访问记录的时候，除了自己的更新记录总是可见之外，还有这几种情况：

- 如果记录的 trx_id 值小于 Read View 中的 min_trx_id 值，表示这个版本的记录是在创建 Read View 前已经提交的事务生成的，所以该版本的记录对当前事务可见。
- 如果记录的 trx_id 值大于等于 Read View 中的 max_trx_id 值，表示这个版本的记录是在创建 Read View 后才启动的事务生成的，所以该版本的记录对当前事务不可见。
- 如果记录的 trx_id 值在 Read View 的min_trx_id和max_trx_id之间，需要判断 trx_id 是否在 m_ids 列表中：
  - 如果记录的 trx_id 在 m_ids 列表中，表示生成该版本记录的活跃事务依然活跃着(还没提交事务)，所以该版本的记录对当前事务不可见。
  = 如果记录的 trx_id 不在 m_ids 列表中，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务可见

## 幻读是如何解决的？

- **快照读(普通 select 语句)**：是通过 MVCC 方式解决了幻读，可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，查询不出来这条数据的
- **当前读(select ... for update 等语句)**：是通过 next-key lock(记录锁+间隙锁)方式解决了幻读，因为当执行 select ... for update 语句的时候会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入

> **失败**
> **对于快照读**：MVCC 并不能完全避免幻读现象。当事务 A 更新了一条事务 B 插入的记录，那么事务 A 前后两次查询的记录条目就不一样了，所以就发生幻读
> **对于当前读**：如果事务开启后，并没有执行当前读，而是先快照读，然后这期间如果其他事务插入了一条记录，那么事务后续使用当前读进行查询的时候，就会发现两次查询的记录条目就不一样了，所以就发生幻读
> 即 **MySQL 可重复读隔离级别并没有彻底解决幻读，只是很大程度上避免了幻读现象的发生**
> **尽量在开启事务之后，马上执行 select ... for update 这类当前读的语句**，因为它会对记录加 next-key lock，从而避免其他事务插入一条新记录

## 读提交怎么实现的？

读提交隔离级别是在**每次读取数据时，都会生成一个新的 Read View**。事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间**另外一个事务修改了该记录，并提交了事务**。

# 索引

## MySQL 为什么使用 B+ 树来作索引，它的优势什么？

### 特性和定义

B+ Tree 是一种多叉树，叶子节点才存放数据，非叶子节点只存放索引，每个节点里的数据是按主键顺序存放的。在叶子节点中，包括了所有的索引值信息，并且每一个叶子节点都指向下一个叶子节点，形成一个链表。B+ Tree 存储千万级的数据只需要 3-4 层高度就可以满足，千万级的表查询目标数据最多需要 3-4 次磁盘 I/O。

B+ 树和 B 树相比：

- B+ 树**所有关键码都存放在叶节点中**，上层的非叶节点的关键码是其子树中最小关键码的复写
- B+ 树**叶节点包含了全部关键码及指向相应数据记录存放地址的指针**，且叶节点本身按关键码从小到大顺序连接
- B+ 树在搜索过程中，**如果查询和内部节点的关键字一致，那么搜索过程不停止，而是继续向下搜索这个分支**

### 优势

- **单点查询**：B 树进行单个索引查询时，最快可以在 O(1) 的时间代价内就查到。从平均时间代价来看，会比 B+ 树稍快一些。但是 B 树的查询波动会比较大，因为每个节点即存索引又存记录，所以有时候访问到了非叶子节点就可以找到索引，而有时需要访问到叶子节点才能找到索引。B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，数据量相同的情况下，B+ 树的非叶子节点可以存放更多的索引，查询底层节点的磁盘 I/O 次数会更少
- **插入和删除效率**：B+ 树有大量的冗余节点，删除一个节点的时候，可以直接从叶子节点中删除，甚至可以不动非叶子节点，删除非常快。B+ 树的插入也是一样，有冗余节点，插入可能存在节点的分裂(如果节点饱和)，但是最多只涉及树的一条路径。B 树没有冗余节点，删除节点的时候非常复杂，可能涉及复杂的树的变形
- **范围查询**：B+ 树所有叶子节点间有一个链表进行连接，而 B 树没有将所有叶子节点用链表串联起来的结构，因此只能通过树的遍历来完成范围查询，范围查询效率不如 B+ 树。B+ 树的插入和删除效率更高。存在大量范围检索的场景，适合使用 B+ 树，比如数据库。而对于大量的单个索引查询的场景，可以考虑 B 树，比如 nosql 的 MongoDB

### 对比

- **B+ Tree 对比 B Tree**：B+Tree 只在叶子节点存储数据，而 B 树 的非叶子节点也要存储数据，所以 B+Tree 的单个节点的数据量更小，在相同的磁盘 I/O 次数下，就能查询更多的节点。B+ Tree 叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找，而 B 树无法做到这一点
- **B+ Tree 对比 二叉树**：对于有 N 个叶子节点的 B+ Tree，其搜索复杂度为 O(logdN)，其中 d 表示节点允许的最大子节点个数。在实际的应用当中， d 值是大于 100 的，即使数据达到千万级别时，B+ Tree 的高度依然维持在 3~4 层左右，一次数据查询操作只需要做 3~4 次的磁盘 I/O 操作就能查询到。二叉树的每个父节点的儿子节点个数是 2 个，意味着其搜索复杂度为 O(logN)，二叉树检索到目标数据所经历的磁盘 I/O 次数要更多
- **B+ Tree 对比 Hash**：Hash 在做等值查询的时候效率高，搜索复杂度为 O(1)。但是 Hash 表不适合做范围查询

## 索引有哪些种类？

- **单值索引**：即一个索引只包含单个列，一个表可以有多个单列索引
  - 建表时，加上 key(列名) 指定
  - 单独创建，create index 索引名 on 表名(列名)
  - 单独创建，alter table 表名 add index 索引名(列名)
- **唯一索引**：索引列的值必须唯一，但允许有 null 且 null 可以出现多次
  - 建表时，加上 unique(列名) 指定
  - 单独创建，create unique index idx 表名(列名) on 表名(列名)
  - 单独创建，alter table 表名 add unique 索引名(列名)
- **主键索引**：设定为主键后数据库会自动建立索引，innodb 为聚簇索引，值必须唯一且不能为 null
  - 建表时，加上 primary key(列名) 指定
- **复合索引**：即一个索引包含多个列
  - 建表时，加上 key(列名列表) 指定
  - 单独创建，create index 索引名 on 表名(列名列表)
  - 单独创建，alter table 表名 add index 索引名(列名列表)
- **前缀索引**：对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引，前缀索引可以建立在字段类型为 char、 varchar、binary、varbinary 的列上。使用前缀索引的目的是为了减少索引占用的存储空间，提升查询效率
  - 单独创建，alter table 表名 add 索引名(column_name(索引长度))

## 什么是最左匹配原则？

使用联合索引时，存在最左匹配原则，也就是按照最左优先的方式进行索引的匹配。使用联合索引进行查询的时候，如果不遵循最左匹配原则，联合索引会失效。

> **(a, b, c)**
> 因为(a, b, c)联合索引，是先按 a 排序，在 a 相同的情况再按 b 排序，在 b 相同的情况再按 c 排序。所以 **b 和 c 是全局无序，局部相对有序的**，这样在没有遵循最左匹配原则的情况下，是无法利用到索引的。**利用索引的前提是索引里的 key 是有序的**
> 联合索引的最左匹配原则在遇到范围查询(如 >、<)的时候就会停止匹配，范围查询的字段可以用到联合索引，在范围查询字段的后面的字段无法用到联合索引。注意，对于 >=、<=、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配

## 索引区分度？

查询优化器发现某个值出现在表的数据行中的百分比(惯用的百分比界线是"30%")很高的时候，会忽略索引，进行全表扫描。

## 联合索引如何进行排序？

给索引列和排序列建立一个联合索引，在查询时，查到一个索引之后，还要对 create_time 排序，用到文件排序 filesort，在 SQL 执行计划中，Extra 列会出现 Using filesort。

可以利用索引的有序性，在排序列建立联合索引，这样根据 status 筛选后的数据就是按照 create_time 排好序的，避免在文件排序，提高了查询效率。

## 使用索引会有哪些缺陷？

虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行 INSERT、UPDATE 和 DELETE。因为更新表时，MySQL 不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息。

实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以索引列也是要占用空间的。

## 什么时候需要/不需要创建索引？

### 需要创建索引
- **表的主关键字**：自动建立唯一索引
- **表的字段唯一约束**：利用索引来保证数据的完整
- **直接条件查询的字段**：经常用于WHERE查询条件的字段，这样能够提高整个表的查询速度
- **查询中与其它表关联的字段**：例如字段建立了外键关系
- **查询中排序的字段**：排序的字段如果通过索引去访问将大大提高排序速度
- **查询中统计或分组统计的字段**：经常用于 GROUP BY 和 ORDER BY 的字段，可以创建联合索引

### 不需要创建索引

- **表记录太少**：表数据太少的时候，不需要创建索引
- **经常插入、删除、修改的字段**：经常更新的字段不用创建索引，索引字段频繁修改，由于要维护 B+Tree的有序性，那么就需要频繁的重建索引，会影响数据库性能
- **数据重复且分布平均的表字段**：假如一个表有10万行记录，性别只有男和女两种值，且每个值的分布概率大约为 50%，那么对这种字段建索引一般不会提高数据库的查询速度。
- **经常和主字段一块查询但主字段索引值比较多的表字段**

## 索引的优化(使用索引的注意事项)？

// TODO

## WHERE 语句索引使用的注意事项？

- **where 子句使用的所有字段，都必须建立索引**
- 确保 **MySQL 版本 5.0 以上**，且查询优化器**开启了 index_merge_union = on**，也就是变量 optimizer_switch 里存在 index_merge_union 且为 on

## 索引什么时候会失效？

- 查询条件中带有 or，除非所有的查询条件都建有索引，
- like 查询是以 % 开头，索引会失效
- 如果列类型是字符串，那在查询条件中需要将数据用引号引用起来，否则索引失效
- 索引列上参与计算，索引失效
- 违背最左匹配原则，索引失效
- 如果 MySQL 估计全表扫描要比使用索引要快，索引失效


# 锁



# 存储引擎



# 日志



# 优化


